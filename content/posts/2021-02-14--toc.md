---
title: 'Riding the Struggle Bus that was the Table of Contents'
date: '2021-02-14T10:37:54-0500'
template: 'post'
draft: false
slug: 'struggle-bus-toc'
tags:
  - 'Tutorial'
  - 'React'
  - 'Update'
description: 'All aboard üöå + life update'
socialImage: '/media/socialImages/github-commit-bot.jpg'
category: 'ahh'
minutes: '4'
---

## Life update

In the beginning of January I started working for [Gather Town](https://gather.town/). On 1/21, I returned to campus after being away for 10 months. After a week of quarantine, I started my last semester at Princeton, while still working part time for Gather. **Read**: been vvv busy and this blog has been put on the back burner. But I finally made time to finish a feature that has been 4 months in the making.

If you're on desktop and you look right ‚û°Ô∏è, you'll see a shiny new feature -- table of contents that link to headings and dynamically indicate location as you scroll!!

## ToC initial stab

I actually had wanted to implement a table of contents since the inception of this blog site. On 10/29, I put up a [draft PR](https://github.com/karenying/blog.karenying.com/pull/1) with this attempt. Looking back, this was definitely not the right way to go about it.

I passed in the HTML of the post content as a string into my ToC component, created an entirely new `document` element with it, and grabbed all the header elements... a big performance yike indeed. Well, it worked (although I hadn't implemented the scroll indicators yet) but I had to find a way to generate ToC at build time. Defeated, I gave up on ToC until mid January.

## ToC take two

On 1/17, my friend and former COS 426: Computer Graphics TA, Reilly Bova, showed me his newly redone [COS 426 website](https://www.cs.princeton.edu/courses/archive/spring20/cos426/assignments/A1/). He had implemented the exact ToC I wanted so I poked around his source code and found the key idea to generating ToC at build time. You can query the headings inside the `post-template` markdown GraphQL query:

```graphql
markdownRemark(fields: { slug: { eq: $slug } }) {
  html
  ...
  headings {
    depth
  }
}
```

`depth` is what level heading and `value` is the title text content. And now I can prop-drill the `headings` data into my `TableOfContents` component.

With this out of the way, I ran into a new problem, how do I generate the relative link to the header? All I have is the header title, not the slug. To answer this, I looked at the [source code](https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-remark-autolink-headers) for `gatsby-remark-autolink-headers`. This is the plugin I'm using to create the links for headers inside posts so it made sense to use whatever algo they're using to generate slugs.

It turns out they use a [package](https://www.npmjs.com/package/github-slugger) called `github-slugger` which takes in text and returns a kebab case string (what GitHub does to generate your repo name).

Armed with these two implementation details, I could finally code the ToC. Along the way I faced amany challenges / bugs. Here are a few:

### Too deep headings

When I write blog posts, I never use level 1 headings (`#`) because I think the text looks too big and the title of the post serves this purpose. So I use headings 2 - 4. But for the ToC I only wanted headings of level 2 and 3. The solution was obvious yet I had some gross code that checked header depth.

**Solution**: use a JS `filter` function

```jsx
<TableOfContents headings={headings.filter((h) => h.depth <= 3)} />
```

### Never resetting github-slugger

### Resetting github-slugger too much

### Code snippets in header titles

### Over optimizing for scroll direction

### Checking url to determine active heading

### "window" is not available during server side rendering

### Too much top buffer

## Final / current implementation
